{"remainingRequest":"/mnt/c/Users/matth/git/cos243/ride-share/node_modules/babel-loader/lib/index.js!/mnt/c/Users/matth/git/cos243/ride-share/node_modules/vuetify/lib/util/mergeData.js","dependencies":[{"path":"/mnt/c/Users/matth/git/cos243/ride-share/node_modules/vuetify/lib/util/mergeData.js","mtime":1605643973821},{"path":"/mnt/c/Users/matth/git/cos243/ride-share/node_modules/cache-loader/dist/cjs.js","mtime":1605136929726},{"path":"/mnt/c/Users/matth/git/cos243/ride-share/node_modules/babel-loader/lib/index.js","mtime":1605643974154}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IHsgY2FtZWxpemUsIHdyYXBJbkFycmF5IH0gZnJvbSAnLi9oZWxwZXJzJzsKY29uc3QgcGF0dGVybiA9IHsKICBzdHlsZUxpc3Q6IC87KD8hW14oXSpcKSkvZywKICBzdHlsZVByb3A6IC86KC4qKS8KfTsKCmZ1bmN0aW9uIHBhcnNlU3R5bGUoc3R5bGUpIHsKICBjb25zdCBzdHlsZU1hcCA9IHt9OwoKICBmb3IgKGNvbnN0IHMgb2Ygc3R5bGUuc3BsaXQocGF0dGVybi5zdHlsZUxpc3QpKSB7CiAgICBsZXQgW2tleSwgdmFsXSA9IHMuc3BsaXQocGF0dGVybi5zdHlsZVByb3ApOwogICAga2V5ID0ga2V5LnRyaW0oKTsKCiAgICBpZiAoIWtleSkgewogICAgICBjb250aW51ZTsKICAgIH0gLy8gTWF5IGJlIHVuZGVmaW5lZCBpZiB0aGUgYGtleTogdmFsdWVgIHBhaXIgaXMgaW5jb21wbGV0ZS4KCgogICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7CiAgICAgIHZhbCA9IHZhbC50cmltKCk7CiAgICB9CgogICAgc3R5bGVNYXBbY2FtZWxpemUoa2V5KV0gPSB2YWw7CiAgfQoKICByZXR1cm4gc3R5bGVNYXA7Cn0KCmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlRGF0YSgpIHsKICBjb25zdCBtZXJnZVRhcmdldCA9IHt9OwogIGxldCBpID0gYXJndW1lbnRzLmxlbmd0aDsKICBsZXQgcHJvcDsgLy8gQWxsb3cgZm9yIHZhcmlhZGljIGFyZ3VtZW50IGxlbmd0aC4KCiAgd2hpbGUgKGktLSkgewogICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBkYXRhIHByb3BlcnRpZXMgYW5kIGV4ZWN1dGUgbWVyZ2Ugc3RyYXRlZ2llcwogICAgLy8gT2JqZWN0LmtleXMgZWxpbWluYXRlcyBuZWVkIGZvciBoYXNPd25Qcm9wZXJ0eSBjYWxsCiAgICBmb3IgKHByb3Agb2YgT2JqZWN0LmtleXMoYXJndW1lbnRzW2ldKSkgewogICAgICBzd2l0Y2ggKHByb3ApIHsKICAgICAgICAvLyBBcnJheSBtZXJnZSBzdHJhdGVneSAoYXJyYXkgY29uY2F0ZW5hdGlvbikKICAgICAgICBjYXNlICdjbGFzcyc6CiAgICAgICAgY2FzZSAnZGlyZWN0aXZlcyc6CiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gbWVyZ2VDbGFzc2VzKG1lcmdlVGFyZ2V0W3Byb3BdLCBhcmd1bWVudHNbaV1bcHJvcF0pOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlICdzdHlsZSc6CiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gbWVyZ2VTdHlsZXMobWVyZ2VUYXJnZXRbcHJvcF0sIGFyZ3VtZW50c1tpXVtwcm9wXSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy8gU3BhY2UgZGVsaW1pdGVkIHN0cmluZyBjb25jYXRlbmF0aW9uIHN0cmF0ZWd5CgogICAgICAgIGNhc2UgJ3N0YXRpY0NsYXNzJzoKICAgICAgICAgIGlmICghYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGlmIChtZXJnZVRhcmdldFtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gJyc7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKG1lcmdlVGFyZ2V0W3Byb3BdKSB7CiAgICAgICAgICAgIC8vIE5vdCBhbiBlbXB0eSBzdHJpbmcsIHNvIGNvbmNhdGVuYXRlCiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdICs9ICcgJzsKICAgICAgICAgIH0KCiAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSArPSBhcmd1bWVudHNbaV1bcHJvcF0udHJpbSgpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy8gT2JqZWN0LCB0aGUgcHJvcGVydGllcyBvZiB3aGljaCB0byBtZXJnZSB2aWEgYXJyYXkgbWVyZ2Ugc3RyYXRlZ3kgKGFycmF5IGNvbmNhdGVuYXRpb24pLgogICAgICAgIC8vIENhbGxiYWNrIG1lcmdlIHN0cmF0ZWd5IG1lcmdlcyBjYWxsYmFja3MgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXksCiAgICAgICAgLy8gc28gdGhhdCB0aGUgbGFzdCBkZWZpbmVkIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCBmaXJzdC4KICAgICAgICAvLyBUaGlzIGlzIGRvbmUgc2luY2UgdG8gbWltaWMgaG93IE9iamVjdC5hc3NpZ24gbWVyZ2luZwogICAgICAgIC8vIHVzZXMgdGhlIGxhc3QgZ2l2ZW4gdmFsdWUgdG8gYXNzaWduLgoKICAgICAgICBjYXNlICdvbic6CiAgICAgICAgY2FzZSAnbmF0aXZlT24nOgogICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXVtwcm9wXSkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9IG1lcmdlTGlzdGVuZXJzKG1lcmdlVGFyZ2V0W3Byb3BdLCBhcmd1bWVudHNbaV1bcHJvcF0pOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vIE9iamVjdCBtZXJnZSBzdHJhdGVneQoKICAgICAgICBjYXNlICdhdHRycyc6CiAgICAgICAgY2FzZSAncHJvcHMnOgogICAgICAgIGNhc2UgJ2RvbVByb3BzJzoKICAgICAgICBjYXNlICdzY29wZWRTbG90cyc6CiAgICAgICAgY2FzZSAnc3RhdGljU3R5bGUnOgogICAgICAgIGNhc2UgJ2hvb2snOgogICAgICAgIGNhc2UgJ3RyYW5zaXRpb24nOgogICAgICAgICAgaWYgKCFhcmd1bWVudHNbaV1bcHJvcF0pIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKCFtZXJnZVRhcmdldFtwcm9wXSkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9IHt9OwogICAgICAgICAgfQoKICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0geyAuLi5hcmd1bWVudHNbaV1bcHJvcF0sCiAgICAgICAgICAgIC4uLm1lcmdlVGFyZ2V0W3Byb3BdCiAgICAgICAgICB9OwogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy8gUmVhc3NpZ25tZW50IHN0cmF0ZWd5IChubyBtZXJnZSkKCiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIC8vIHNsb3QsIGtleSwgcmVmLCB0YWcsIHNob3csIGtlZXBBbGl2ZQogICAgICAgICAgaWYgKCFtZXJnZVRhcmdldFtwcm9wXSkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9IGFyZ3VtZW50c1tpXVtwcm9wXTsKICAgICAgICAgIH0KCiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiBtZXJnZVRhcmdldDsKfQpleHBvcnQgZnVuY3Rpb24gbWVyZ2VTdHlsZXModGFyZ2V0LCBzb3VyY2UpIHsKICBpZiAoIXRhcmdldCkgcmV0dXJuIHNvdXJjZTsKICBpZiAoIXNvdXJjZSkgcmV0dXJuIHRhcmdldDsKICB0YXJnZXQgPSB3cmFwSW5BcnJheSh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHBhcnNlU3R5bGUodGFyZ2V0KSA6IHRhcmdldCk7CiAgcmV0dXJuIHRhcmdldC5jb25jYXQodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBwYXJzZVN0eWxlKHNvdXJjZSkgOiBzb3VyY2UpOwp9CmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNsYXNzZXModGFyZ2V0LCBzb3VyY2UpIHsKICBpZiAoIXNvdXJjZSkgcmV0dXJuIHRhcmdldDsKICBpZiAoIXRhcmdldCkgcmV0dXJuIHNvdXJjZTsKICByZXR1cm4gdGFyZ2V0ID8gd3JhcEluQXJyYXkodGFyZ2V0KS5jb25jYXQoc291cmNlKSA6IHNvdXJjZTsKfQpleHBvcnQgZnVuY3Rpb24gbWVyZ2VMaXN0ZW5lcnMoLi4uYXJncykgewogIGlmICghYXJnc1swXSkgcmV0dXJuIGFyZ3NbMV07CiAgaWYgKCFhcmdzWzFdKSByZXR1cm4gYXJnc1swXTsKICBjb25zdCBkZXN0ID0ge307CgogIGZvciAobGV0IGkgPSAyOyBpLS07KSB7CiAgICBjb25zdCBhcmcgPSBhcmdzW2ldOwoKICAgIGZvciAoY29uc3QgZXZlbnQgaW4gYXJnKSB7CiAgICAgIGlmICghYXJnW2V2ZW50XSkgY29udGludWU7CgogICAgICBpZiAoZGVzdFtldmVudF0pIHsKICAgICAgICAvLyBNZXJnZSBjdXJyZW50IGxpc3RlbmVycyBiZWZvcmUgKGJlY2F1c2Ugd2UgYXJlIGl0ZXJhdGluZyBiYWNrd2FyZHMpLgogICAgICAgIC8vIE5vdGUgdGhhdCBuZWl0aGVyICJ0YXJnZXQiIG9yICJzb3VyY2UiIG11c3QgYmUgYWx0ZXJlZC4KICAgICAgICBkZXN0W2V2ZW50XSA9IFtdLmNvbmNhdChhcmdbZXZlbnRdLCBkZXN0W2V2ZW50XSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gU3RyYWlnaHQgYXNzaWduLgogICAgICAgIGRlc3RbZXZlbnRdID0gYXJnW2V2ZW50XTsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIGRlc3Q7Cn0="},{"version":3,"sources":["../../src/util/mergeData.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\n/* eslint-disable max-statements */\nimport { VNodeData } from 'vue'\nimport { camelize, wrapInArray } from './helpers'\n\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/,\n} as const\n\nfunction parseStyle (style: string) {\n  const styleMap: Dictionary<any> = {}\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp)\n    key = key.trim()\n    if (!key) {\n      continue\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === 'string') {\n      val = val.trim()\n    }\n    styleMap[camelize(key)] = val\n  }\n\n  return styleMap\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nexport default function mergeData (...vNodeData: VNodeData[]): VNodeData\nexport default function mergeData (): VNodeData {\n  const mergeTarget: VNodeData & Dictionary<any> = {}\n  let i: number = arguments.length\n  let prop: string\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Space delimited string concatenation strategy\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = ''\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' '\n          }\n          mergeTarget[prop] += arguments[i][prop].trim()\n          break\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Object merge strategy\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] }\n          break\n        // Reassignment strategy (no merge)\n        default: // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop]\n          }\n      }\n    }\n  }\n\n  return mergeTarget\n}\n\nexport function mergeStyles (\n  target: undefined | string | object[] | object,\n  source: undefined | string | object[] | object\n) {\n  if (!target) return source\n  if (!source) return target\n\n  target = wrapInArray(typeof target === 'string' ? parseStyle(target) : target)\n\n  return (target as object[]).concat(typeof source === 'string' ? parseStyle(source) : source)\n}\n\nexport function mergeClasses (target: any, source: any) {\n  if (!source) return target\n  if (!target) return source\n\n  return target ? wrapInArray(target).concat(source) : source\n}\n\nexport function mergeListeners (...args: [\n  { [key: string]: Function | Function[] } | undefined,\n  { [key: string]: Function | Function[] } | undefined\n]) {\n  if (!args[0]) return args[1]\n  if (!args[1]) return args[0]\n\n  const dest: { [key: string]: Function | Function[] } = {}\n\n  for (let i = 2; i--;) {\n    const arg = args[i]\n    for (const event in arg) {\n      if (!arg[event]) continue\n\n      if (dest[event]) {\n        // Merge current listeners before (because we are iterating backwards).\n        // Note that neither \"target\" or \"source\" must be altered.\n        dest[event] = ([] as Function[]).concat(arg[event], dest[event])\n      } else {\n        // Straight assign.\n        dest[event] = arg[event]\n      }\n    }\n  }\n\n  return dest\n}\n"],"sourceRoot":""}]}